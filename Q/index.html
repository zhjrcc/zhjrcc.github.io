<!DOCTYPE html><html lang="zh-CN"><head><title>问题集</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="icon" href="https://unpkg.com/gitimages/favicon.ico"><link rel="stylesheet" href="/css/post.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="inner"><h1>问题集</h1><div class="time">First published 2024-07-07</div><div class="updatedTime">Modified 2024-07-07</div><pre><code>test.[[Prototype]]为什么不能访问原型链
</code></pre>
<p>在 JavaScript 中，[[Prototype]] 是一个内部属性，通常通过 <strong>proto</strong> 属性或 Object.getPrototypeOf() 方法访问对象的原型链。正如您提到的，test.[[Prototype]] 的语法不正确，因为 [[Prototype]] 不是标准的 JavaScript 语法用于访问对象的原型链。<br>正确的方式是使用如下方法之一来访问对象的原型链：<br>使用 <strong>proto</strong> 属性（不推荐使用，因为它不是标准的 ECMAScript 语法，但大多数现代浏览器支持）：<br>javascript<br>const test &#x3D; {};<br>const prototypeObj &#x3D; test.<strong>proto</strong>;<br>使用 Object.getPrototypeOf() 方法（推荐的方法，是标准的 ECMAScript 方法）：<br>javascript<br>const test &#x3D; {};<br>const prototypeObj &#x3D; Object.getPrototypeOf(test);</p>
<p>这两种方法都可以用来获取对象 test 的原型链。JavaScript 的对象在创建时都有一个原型链，通过 <strong>proto</strong> 或 Object.getPrototypeOf() 可以访问到它们。</p>
<pre><code>app.get(&quot;/:code&quot;, async (req, res) =&gt; &#123;
  console.log(req.query.code)&#125;，
为什么会输出undefined
</code></pre>
<p>在你的代码中，路由参数 :code 是通过路径传递的，而不是通过查询参数（query parameter）传递的。路由参数是通过路径的一部分传递的，例如 &#x2F;abc 中的 abc 部分。<br>如果你想通过查询参数访问 code，你需要确保客户端将参数作为查询字符串的一部分发送，例如 &#x2F;path?code&#x3D;value，然后你可以通过 req.query.code 来获取该参数的值。<br>现在，假设你的路由是 &#x2F;abc，那么对应的代码应该是这样的：<br>javascript<br>app.get(“&#x2F;:code”, async (req, res) &#x3D;&gt; {<br>  console.log(req.params.code); &#x2F;&#x2F; 这里使用 req.params.code 访问路由参数<br>});</p>
<p>如果你希望通过查询参数访问 code，则客户端请求应该为 &#x2F;path?code&#x3D;value，然后可以这样访问：<br>javascript<br>app.get(“&#x2F;path”, async (req, res) &#x3D;&gt; {<br>  console.log(req.query.code); &#x2F;&#x2F; 这里使用 req.query.code 访问查询参数<br>});</p>
<p>所以，确保你正在使用正确的方法来访问客户端发送的参数，这样就可以正确地获取和处理它们了。</p>
<pre><code>也就是说，只需要指定开发依赖就行了，默认是普通依赖
</code></pre>
<p>在现代的 npm 中，默认行为已经变更，无需显式指定 –save 或 -S 选项来安装包作为普通依赖。如果你执行像 npm install package-name 这样的命令，npm 会自动将包安装为项目的普通依赖（dependencies），而不是开发依赖（devDependencies）。<br>因此，如果你希望将包作为开发依赖安装，需要显式指定 –save-dev 或 -D 选项。例如：<br>bash<br>npm install –save-dev package-name</p>
<p>或者使用缩写形式：<br>bash<br>npm install -D package-name</p>
<p>总结起来：<br>默认行为：npm install package-name 将包安装为项目的普通依赖（dependencies）。<br>显式指定开发依赖：需要使用 –save-dev 或 -D 选项来将包安装为项目的开发依赖（devDependencies）。</p>
<p>这样可以确保安装的包按照你的预期添加到项目的相应依赖列表中。</p>
<pre><code>vscode打开文件，文件夹总是自动打开
</code></pre>
<p>VSCODE-&gt;autoReveal-&gt;FALSE</p>
<h2 id="React组件，React元素，React实例"><a href="#React组件，React元素，React实例" class="headerlink" title="React组件，React元素，React实例"></a>React组件，React元素，React实例</h2><ol>
<li>React组件就是一个函数或者类， 使用JSX语法返回React元素，封装逻辑，状态。</li>
<li>React元素就是描述UI的简单对象，可以由JSX语法创建或则CreateElement创建。</li>
<li>React实例就是React组件的实际对象，由React在内部创建和管理。</li>
</ol>
<pre><code>const Text() =&gt; &#123;
  return (
    &lt;p&gt;
      Text....
    &lt;p/&gt;
  )
&#125;
const App() =&gt; &#123;return(
  &lt;div&gt;
    &lt;Text/&gt;
  &lt;/div&gt;
)&#125;

// Text就是React函数组件，&lt;Text/&gt;就是一个React元素。
// 在React渲染Text组件时，在内部生成的它的一个实际对象，就是一个React实例。
</code></pre>
<pre><code>详细解释一下：lifting state in React
</code></pre>
<p>在 React 中，”lifting state up” 是一种将状态提升到离需要该状态的组件最近的共同祖先组件中的技术。这使得多个组件能够共享和同步状态。</p>
<h3 id="为什么需要提升状态"><a href="#为什么需要提升状态" class="headerlink" title="为什么需要提升状态"></a>为什么需要提升状态</h3><p>当多个组件需要共享某些状态时，将状态提升到它们的共同祖先组件中有助于：</p>
<ol>
<li><strong>避免状态不一致</strong>: 确保所有需要该状态的组件都能访问和更新相同的状态。</li>
<li><strong>简化状态管理</strong>: 将状态集中管理，使得数据流更加明确和易于调试。</li>
<li><strong>提高组件的可复用性</strong>: 子组件不再负责状态管理，可以更加专注于展示和行为。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们有两个子组件 <code>TemperatureInput</code>，它们分别输入摄氏温度和华氏温度，并且需要互相转换和同步显示。</p>
<h4 id="Step-1-创建子组件"><a href="#Step-1-创建子组件" class="headerlink" title="Step 1: 创建子组件"></a>Step 1: 创建子组件</h4><p>首先，我们创建两个子组件 <code>TemperatureInput</code> 来输入温度。</p>
<pre><code class="jsx">function TemperatureInput(&#123; scale, temperature, onTemperatureChange &#125;) &#123;
  const scaleNames = &#123;
    c: &#39;Celsius&#39;,
    f: &#39;Fahrenheit&#39;
  &#125;;

  const handleChange = (e) =&gt; &#123;
    onTemperatureChange(e.target.value);
  &#125;;

  return (
    &lt;fieldset&gt;
      &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt;
      &lt;input value=&#123;temperature&#125; onChange=&#123;handleChange&#125; /&gt;
    &lt;/fieldset&gt;
  );
&#125;
</code></pre>
<h4 id="Step-2-创建父组件并提升状态"><a href="#Step-2-创建父组件并提升状态" class="headerlink" title="Step 2: 创建父组件并提升状态"></a>Step 2: 创建父组件并提升状态</h4><p>在父组件中管理状态，并通过 props 将状态传递给子组件。</p>
<pre><code class="jsx">function Calculator() &#123;
  const [temperature, setTemperature] = useState(&#39;&#39;);
  const [scale, setScale] = useState(&#39;c&#39;);

  const handleCelsiusChange = (temperature) =&gt; &#123;
    setTemperature(temperature);
    setScale(&#39;c&#39;);
  &#125;;

  const handleFahrenheitChange = (temperature) =&gt; &#123;
    setTemperature(temperature);
    setScale(&#39;f&#39;);
  &#125;;

  const tryConvert = (temperature, convert) =&gt; &#123;
    const input = parseFloat(temperature);
    if (Number.isNaN(input)) &#123;
      return &#39;&#39;;
    &#125;
    const output = convert(input);
    const rounded = Math.round(output * 1000) / 1000;
    return rounded.toString();
  &#125;;

  const toCelsius = (fahrenheit) =&gt; (fahrenheit - 32) * 5 / 9;
  const toFahrenheit = (celsius) =&gt; (celsius * 9 / 5) + 32;

  const celsius = scale === &#39;f&#39; ? tryConvert(temperature, toCelsius) : temperature;
  const fahrenheit = scale === &#39;c&#39; ? tryConvert(temperature, toFahrenheit) : temperature;

  return (
    &lt;div&gt;
      &lt;TemperatureInput
        scale=&quot;c&quot;
        temperature=&#123;celsius&#125;
        onTemperatureChange=&#123;handleCelsiusChange&#125;
      /&gt;
      &lt;TemperatureInput
        scale=&quot;f&quot;
        temperature=&#123;fahrenheit&#125;
        onTemperatureChange=&#123;handleFahrenheitChange&#125;
      /&gt;
    &lt;/div&gt;
  );
&#125;
</code></pre>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol>
<li><strong>状态管理</strong>: <code>Calculator</code> 组件管理两个状态变量 <code>temperature</code> 和 <code>scale</code>。<ul>
<li><code>temperature</code>: 当前输入的温度值。</li>
<li><code>scale</code>: 当前输入的温度单位（摄氏或华氏）。</li>
</ul>
</li>
<li><strong>状态提升</strong>: 将温度和单位的状态提升到 <code>Calculator</code> 组件中。两个 <code>TemperatureInput</code> 组件通过 props 从父组件接收状态值和更新函数。</li>
<li><strong>同步状态</strong>: 当用户在任何一个 <code>TemperatureInput</code> 组件中输入温度值时，父组件的状态会更新，并且将更新的状态通过 props 传递给另一个 <code>TemperatureInput</code> 组件，从而实现温度值的同步显示。</li>
<li><strong>转换函数</strong>: <code>tryConvert</code>, <code>toCelsius</code>, 和 <code>toFahrenheit</code> 函数用于在不同温度单位之间进行转换。</li>
</ol>
<h3 id="提升状态的步骤"><a href="#提升状态的步骤" class="headerlink" title="提升状态的步骤"></a>提升状态的步骤</h3><ol>
<li><strong>识别共享状态</strong>: 确定哪些状态需要在多个组件之间共享。</li>
<li><strong>提升状态</strong>: 将共享状态提升到这些组件的最近公共祖先组件中。</li>
<li><strong>传递状态和回调函数</strong>: 通过 props 将共享状态和用于更新状态的回调函数传递给子组件。</li>
<li><strong>使用状态和回调</strong>: 在子组件中使用传递的状态和回调函数。</li>
</ol>
<h3 id="什么时候需要提升状态"><a href="#什么时候需要提升状态" class="headerlink" title="什么时候需要提升状态"></a>什么时候需要提升状态</h3><ul>
<li>当多个组件需要访问或修改相同的状态时。</li>
<li>当状态位于一个组件中，但需要传递给兄弟组件时。</li>
<li>当需要避免通过过多的嵌套传递状态时。</li>
</ul>
<p>通过提升状态，可以更清晰地管理 React 应用中的数据流和状态更新，提高组件的复用性和可维护性。</p>
<p class="backHome"><span></span><a href="/">Back</a><span>↶</span></p></div><script src="/js/highlight.min.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>