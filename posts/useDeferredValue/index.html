<!DOCTYPE html><html lang="zh-CN"><head><title>useDeferredValue</title><meta name="referrer" content="no-referrer"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="icon" href="https://gitee.com/zhjrcc/blog-images/raw/master/favicon.ico?v=2"><link rel="stylesheet" href="/css/post.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="inner"><h1>useDeferredValue</h1><div class="time">First published 2025-02-13</div><div class="updatedTime">Modified 2025-02-13</div><p class="backHome"><span></span><a href="/">Back</a><span>↶</span></p><meta name="referrer" content="no-referrer">


<p>useDeferredValue 是 React 提供的一个 Hook，用于延迟某些状态的更新，从而避免在高优先级任务（如用户输入）时阻塞主线程，提升应用的响应性。以下是 useDeferredValue 的常见使用场景：</p>
<ol>
<li>优化实时搜索<br>在实时搜索场景中，用户输入时会触发搜索结果的更新。如果直接使用输入值更新结果，可能会导致输入框卡顿。通过 useDeferredValue，可以将搜索结果的更新延迟，确保输入框始终保持流畅。<br>jsx复制<br>function SearchBox() {<br>  const [query, setQuery] &#x3D; useState(‘’);<br>  const deferredQuery &#x3D; useDeferredValue(query);</li>
</ol>
<p>  return (<br>    <div><br>      &lt;input<br>        value&#x3D;{query}<br>        onChange&#x3D;{(e) &#x3D;&gt; setQuery(e.target.value)}<br>        placeholder&#x3D;”Search…”<br>      &#x2F;&gt;<br>      <Results query={deferredQuery} /><br>    </div><br>  );<br>}<br>2. 处理高开销渲染<br>当组件需要渲染大量数据或复杂组件树时，直接更新可能会导致性能问题。使用 useDeferredValue 可以将这些高开销的渲染任务延迟到低优先级任务中执行。<br>jsx复制<br>function App() {<br>  const [users, setUsers] &#x3D; useState([]);<br>  const deferredUsers &#x3D; useDeferredValue(users);</p>
<p>  useEffect(() &#x3D;&gt; {<br>    async function fetchData() {<br>      const response &#x3D; await fetch(‘<a target="_blank" rel="noopener" href="https://api.example.com/users">https://api.example.com/users</a>‘);<br>      const data &#x3D; await response.json();<br>      setUsers(data);<br>    }<br>    fetchData();<br>  }, []);</p>
<p>  return (<br>    <ul><br>      {deferredUsers.map((user) &#x3D;&gt; (<br>        <li key={user.id}>{user.name}</li><br>      ))}<br>    </ul><br>  );<br>}<br>3. 结合 useTransition 控制加载状态<br>在某些场景下，可以将 useDeferredValue 与 useTransition 结合使用，以更好地控制加载状态。<br>jsx复制<br>function App() {<br>  const [query, setQuery] &#x3D; useState(‘’);<br>  const [isPending, startTransition] &#x3D; useTransition();<br>  const deferredQuery &#x3D; useDeferredValue(query);</p>
<p>  const handleSearch &#x3D; (e) &#x3D;&gt; {<br>    startTransition(() &#x3D;&gt; {<br>      setQuery(e.target.value);<br>    });<br>  };</p>
<p>  return (<br>    <div><br>      <input onChange={handleSearch} /><br>      {isPending &amp;&amp; <Spinner />}<br>      <Results query={deferredQuery} /><br>    </div><br>  );<br>}<br>4. 避免复杂对象的无效更新<br>如果传递给 useDeferredValue 的是复杂对象，可能会导致多次无效渲染。建议使用 useMemo 缓存对象，确保延迟值的稳定性。<br>jsx复制<br>const filters &#x3D; useMemo(() &#x3D;&gt; ({ keyword, category }), [keyword, category]);<br>const deferredFilters &#x3D; useDeferredValue(filters);<br>注意事项<br>仅对高开销渲染使用：useDeferredValue 适用于复杂组件或大数据量的场景，对简单渲染使用可能会增加不必要的复杂度。<br>避免滥用延迟：过度延迟可能导致用户感知到卡顿，需要平衡响应速度与流畅性。<br>与 Suspense 协同使用：如果延迟值依赖异步数据，需配合 Suspense 显示加载状态。<br>通过合理使用 useDeferredValue，可以有效提升 React 应用在复杂场景下的性能和用户体验。</p>
<p class="backHome"><span></span><a href="/">Back</a><span>↶</span></p></div><script src="/js/highlight.min.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>