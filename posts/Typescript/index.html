<!DOCTYPE html><html lang="zh-CN"><head><title>Typescript</title><meta name="referrer" content="no-referrer"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="icon" href="https://gitee.com/zhjrcc/blog-images/raw/master/favicon.ico?v=2"><link rel="stylesheet" href="/css/post.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="inner"><h1>Typescript</h1><div class="time">First published 2025-12-16</div><div class="updatedTime">Modified 2025-12-16</div><p class="backHome"><span></span><a href="/">Back</a><span>↶</span></p><meta name="referrer" content="no-referrer">

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>1.类型声明</p>
<pre><code class="js">let a: number = 1
function add(a: number, b: number): number &#123;
  return a + b
&#125;
</code></pre>
<p>2.类型推断<br>函数结果自动推断为一个 number</p>
<pre><code class="js">let add(a: number ,b: number) &#123;
  return a + b
&#125;
</code></pre>
<p>3.Typescript编译<br>npx tsc xx.ts,将ts文件编译成js文件，该命令可以添加一些参数，也可以在当前目录在床见一个tsconfig.json，在这个文件中填入相关的参数，执行该命令时就会依照配置执行。</p>
<p>4.值与类型<br>typescript处理的是类型，javascript处理的是值</p>
<p>5.Typescript Playground<br>Typescript官方的在线TS编辑器，可自动生成JS</p>
<p>6.TSC编译器<br>TS官方的编译器，npm i typescript</p>
<p>7.TS-NODE<br>直接在终端中执行TS文件，不需要编译JS再执行。</p>
<h2 id="any-unknown-never"><a href="#any-unknown-never" class="headerlink" title="any unknown never"></a>any unknown never</h2><p>1.any<br>表示任何类型，any类型可以被赋值为任何类型,any类型可以赋值给任何类型。</p>
<p>2.unknown<br>表示未知类型，unknown类型可以被赋值为任何类型，但unknown类型不能赋值给任何类型，除非它通过类型断言或类型守卫被缩小为具体类型。unknown可以被认为是安全版本的any类型。</p>
<p>3.never<br>表示一个空类型，never类型可以赋值给任何类型,但never类型不能被赋值为任何类型。never可以被认为是unknown的对立面。</p>
<h2 id="TypeScript的类型系统"><a href="#TypeScript的类型系统" class="headerlink" title="TypeScript的类型系统"></a>TypeScript的类型系统</h2><p>1.基本类型<br>number,string,boolean,symbol,object,null,undefined,bigint</p>
<p>2.包装对象类型<br>number,string,boolean都有各自的包装对象Number,String,Boolean，使用new即创建这些对象。为此，TS也给出了类型Number,String,Boolean。(这里注意，symbol也属于基本类型，但它没有真正的包装对象，new Symbol()是会报错的，只能通过Object(symbol)来达到包装对象的目的，所以并没有真的Symbol这个对象)。包装对象类型包含了基本类型，也就是说，Number类型相当于type T &#x3D; Number | number.</p>
<p>3.Object与object<br>跟包装对象同理，object表示我们日常开发用到的一般对象(数组，对象，函数)，Object则包含JS所有广义的对象（包含了包装对象），因此Object类型可以表示所有JS的对象，除了特殊的null和undefined.</p>
<p>4.undefined和null<br>undefined和null类型都分别只有一个值，就是它们本身，在严格模式下(strict:true或者strictNullChecks:true),直接将undefined或null赋值给一个变量，会自动将类型定义为undefined或null，如果不是严格模式下，则会隐式将类型定义为any。</p>
<p>5.值类型<br>TS中，可以将值作为一种类型.<code>let b:1=2</code>会报错，因为b的类型是1，值只能为1。number是这种数值类型的父类型，<code>let a=1;let b:number = a</code>这样设置是没问题的。同理，string,boolean等其他基本类型也是各自值类型的父类型。</p>
<p>6.联合类型<br>联合类型就是多个类型组合在一起，它的值是这个组合中其中的一个类型，比如<code>type T = number | string</code>，那么T类型就表示值类型可以数字或者字符串。</p>
<p>7.交叉类型<br>交叉类型就是多个类型组合在一起，它的值必须同时符合组合中所有的类型，比如<code>type T = number &amp; string</code>，那么T类型就表示值类型必须是数字也是字符串，那就相当于是never空类型了，因为没有任何一个值能同时满足这个条件。</p>
<p>8.type命令<br>可以通过使用type命令来创建类型别名,比如<code>type Name = string; type Age = number; let name:Name = &#39;aa&#39;; let age:Age = 18</code>.</p>
<p>9.typeof运算符<br>typeof type，返回一个TS类型，注意，这个命令的操作值是一个值，但返回的是该值的类型，而不是字符串。这个跟JS中的typeof是有区别的，JS的typeof返回的是该值的类型的一个字符串，比如typeof 1，得到的就是’number’.</p>
<pre><code class="js">// TS中的typeof
let a:number = 1;
let b:typeof a = &#39;adsf&#39;; // 报错，b的类型是a的number类型

console.log(typeof a) //输出number
</code></pre>
<p>10.块级类型声明<br>使用type命令声明类型时，它的作用域是块级作用域。</p>
<p>11.类型的兼容<br>子类型可以用于所有使用父类型的场合。反之，则不行。</p>
<pre><code class="js">let a: 1 = 1
// 不报错
let b: number = a

// 报错，不能将number类型分配给1类型
a = b
</code></pre>
<h2 id="TypeScript的数组类型"><a href="#TypeScript的数组类型" class="headerlink" title="TypeScript的数组类型"></a>TypeScript的数组类型</h2><p>Typescript规定数组的所有成员的类型必须相同，数量可以不确定。<br>1.数组类型声明方式</p>
<pre><code class="js">let arr:number[] = [1,2]
let arr:(number|string)[] = [1,&#39;test&#39;]

let arr:Array&lt;number&gt; = [1,2]
let arr:Array&lt;number|string&gt; = [1,&#39;test&#39;]
</code></pre>
<p>2.数组的类型推断</p>
<pre><code class="js">// arr会被类型推断为是any[]
let arr = []
// arr类型推断更新为number[]
arr.push(1)
// arr类型推断更新为(number|string)[]
arr.push(&#39;test&#39;)
// 只有初始值为空数组会这样进行推断，如果不为空数组则不会更新类型
</code></pre>
<p>3.只读数组<br>只读数组不能做任何修改，是数组的父类型</p>
<pre><code class="js">let arr1:number[] = [1,2]
let arr2: readonly number[] = arr1

let arr3: ReadonlyArray&lt;number&gt; = arr1
let arr4: Readonly&lt;number[]&gt; = arr1
let arr5 = [1, 2] as const
</code></pre>
<p>4.多维数组<br>多维数组的类型定义是给最底层的成员</p>
<pre><code class="js">let arr: number[][] = [[1,2],[3,4,5]]
</code></pre>
<h2 id="TypeScript的元组类型"><a href="#TypeScript的元组类型" class="headerlink" title="TypeScript的元组类型"></a>TypeScript的元组类型</h2><p>元组是Typescript的特有类型，JS只有数组。元组的成员类型可以不一致，可选，数量也可以确定或者不确定,通过扩展运算符可以做到无限数量。需要注意的是，可选元素必须在必选元素之后，可选元素必须在扩展元算符前面。其实可选元素就相当于是T|undefined。<br>如果想让变量定义为元组，需要明确定义类型，否则TS会将它推断为数组。</p>
<pre><code class="js">type T = [number, string]
type T1 = [number, string?]
type T2 = [number, ...string[], boolean]
type T3 = [number,  boolean?,...string[]]

let t: T = [1, &quot;str&quot;]
let t1: T1 = [1]
let t2: T2 = [1, &quot;str1&quot;, &quot;str2&quot;, true]
let t3: T3 = [1, , &quot;str2&quot;]

// TS类型推断为数组，而不是元组
// 此时的arr类型是Array&lt;number|string&gt;,(number|string)[]
let arr = [1, 2]

// 只读元组
let t4: Readonly&lt;[number, string]&gt; = [1, &quot;str&quot;]
let t5: readonly [number, string] = [1,&#39;str&#39;]
</code></pre>
<p>成员数量的推断,TS会对元组的长度进行推断，在各种情况下有差异。</p>
<pre><code class="js">// 一般元组,推断长度为2
let t: [number, string] = [1, &quot;str&quot;]
// 可选元组，推断其可能长度为 1|2|3..|.
let t1: [number, string?, boolean?] = [1, &quot;str&quot;]
// 扩展元组，无法确定其长度
let t2: [number, ...string[]] = [1, &quot;str&quot;, &quot;str&quot;]

console.log(t[2]) // 报错索引2处没元素
console.log(t1[4]) // 报错索引4处没元素
console.log(t2[10]) //不报错，扩展元组无法推测其长度
</code></pre>
<h2 id="Typescript的symbol类型"><a href="#Typescript的symbol类型" class="headerlink" title="Typescript的symbol类型"></a>Typescript的symbol类型</h2><p>symbol用于让对象属性名具有唯一性。TS中使用symbol作为其类型。</p>
<ol>
<li>unique symbol<br>unique symbol可以理解是一个Symbol的值类型，每个unique symbol都是不同的类型。因为symbol和其他基本类型（number，string，boolean）不一样，symbol并没有值类型。unique symbol是TS创建的一个symbol值类型。unique symbol必须是使用用const声明的。其实，只要使用const声明一个Symbol，默认就是unique symbol.将unique symbol作为类属性时，必须要配合static+readonly使用，保证不可改变。</li>
</ol>
<pre><code>const s1: unique symbol = Symbol(&#39;s1&#39;)
const s2: unique symbol = Symbol(&#39;s2&#39;)

s1 = s2 // 报错，这里本身const是常量也是不能重新赋值的
</code></pre>
<ol start="2">
<li>类型推断<br>除了const声明的默认推断就是unique symbol，其他的都是推断为symbol。</li>
</ol>
<h2 id="Typescript的函数类型"><a href="#Typescript的函数类型" class="headerlink" title="Typescript的函数类型"></a>Typescript的函数类型</h2><pre><code class="js">// 基本用法
function f1(x: number, y: number): number &#123;
  return x + y
&#125;

// Function类型,相当于参数类型和返回值都是any
let f2: Function = function (x: number, y: number) &#123;
  return x + y
&#125;

// 可选参数,必须放在必选参数的后面
function f3(x: number, y: number, z?: boolean): number &#123;
  if (z) &#123;
    return x + y
  &#125;
  return 0
&#125;

// 参数默认值
function f4(x: number = 0, y: number = 1): number &#123;
  return x + y
&#125;

// 参数解构
// 下面这个是错误的参数解构模式，因为冒号:在解构里是重命名变量的意思，不标注是类型
function f5(&#123; x: number, y: number &#125;) &#123;
  return x + y
&#125;
// 正确的参数解构模式
function f6(&#123; x, y &#125;: &#123; x: number; y: number &#125;) &#123;
  return x + y
&#125;
f6(&#123; x: 1, y: 2 &#125;)

// rest参数
// 数组
function f7(x: number, ...nums: number[]) &#123;
  let sum = nums.reduce((p, c) =&gt; p + c)
  console.log(sum + x)
&#125;
f7(1, 3, 4)
// 元组
function f8(x: number, ...args: [number, string]) &#123;
  args.push(x)
  console.log(args)
&#125;
f8(1, 1, &quot;str1&quot;)

// readonly只读参数
function f9(arr: readonly number[]) &#123;
  arr[0] = 3
&#125;

// void 类型,如果没显示return，默认就是void
function f10(x: number, y: number): void &#123;
  console.log(x + y)
&#125;

// never类型，空类型，是函数不会正常执行完的类型
// 抛出错误
function fail(msg: string): never &#123;
  throw new Error(msg)
&#125;
// 无线循环执行的函数
const sing = function (): never &#123;
  while (true) &#123;
    console.log(&quot;sing&quot;)
  &#125;
&#125;
// void是正常执行完，没有返回值。never是不能正常执行完，不可能有返回值
// 报错，这个函数是能正常执行完的，只是没有返回值（其实相当于return undefined）
function f11(): never &#123;
  console.log(&quot;void&quot;)
&#125;

// 函数重载
function fo(x: number): number
function fo(x: string, y: string): string
function fo(x: number | string, y?: string): string | number &#123;
  if (typeof x === &quot;number&quot;) &#123;
    return Math.pow(x, x)
  &#125; else if (typeof y === &quot;string&quot;) &#123;
    return x
  &#125;
  throw new Error(&quot;worong parameters&quot;)
&#125;

// 构造函数
class Person &#123;
  name: string
  age: number
  constructor(name: string, age: number) &#123;
    this.name = name
    this.age = age
  &#125;
&#125;

type Create = (
  c: new (name: string, age: number) =&gt; Person,
  name: string,
  age: number
) =&gt; Person

const create: Create = function (c, name, age) &#123;
  return new c(name, age)
&#125;

const p = create(Person, &quot;zhjrcc&quot;, 19)
</code></pre>
<h2 id="TypeScript对象类型"><a href="#TypeScript对象类型" class="headerlink" title="TypeScript对象类型"></a>TypeScript对象类型</h2><pre><code class="js">// 1.基本使用
let o1: &#123; name: string; age: number &#125; = &#123;
  name: &quot;joe&quot;,
  age: 13,
&#125;

// 2.可选属性
type T = &#123; name: string; age: number; adult?: boolean &#125;f

let o2: T = &#123;
  name: &quot;zoey&quot;,
  age: 30,
  adult: true,
&#125;

let o3: T = &#123;
  name: &quot;mike&quot;,
  age: 12,
&#125;

// 3.只读属性
type T1 = &#123; name: string; age: number; readonly sex: string &#125;

let o4:T1 = &#123;
  name: &#39;zusy&#39;,
  age: 33,
  sex: &#39;MM&#39;
&#125;
o4.sex = &#39;GG&#39;

// 4.属性名的索引类型
type T2 = &#123;
  [property: string]: string;
&#125;

let o5: T2 = &#123;
  name: &#39;huyu&#39;,
  age: 27
&#125;

// 5. 解构赋值

type T3 = &#123;
  name: string,
  age: number
&#125;

let &#123;name:o6,age:o7&#125;:T3 = &#123;
  name: &#39;yuki&#39;,
  age: 43
&#125;

// 结构类型原则
type T4 = &#123;
  name: string,
  age: number
&#125;
type T5 = &#123;
  name: string,
  age: number,
  gender: &#39;male&#39;|&#39;femal&#39;
&#125;
let o8:T5 = &#123;
  name: &#39;yuji&#39;,
  age: 187,
  gender: &#39;male&#39;
&#125;
// 这里必须要用变量赋值,不能用字面量,使用字面量会触发&quot;多余属性检查&quot;
let o9: T4 = o8
let o10: T4 = &#123;
  name: &#39;yuji&#39;,
  age: 187,
  gender: &#39;male&#39;
&#125;

// 最小可选属性
type T6 = &#123;
  name?: string,
  age?: number,
&#125;
// 必须含有一个可选属性
let o11: T6 = &#123;gend: &#39;asdf&#39;&#125;

// kong &#123;&#125;
let o12:&#123;&#125; = &#123;&#125;
o12.prop = 12
</code></pre>
<h2 id="Typescript的interface"><a href="#Typescript的interface" class="headerlink" title="Typescript的interface"></a>Typescript的interface</h2><pre><code class="js">// 基本用法
interface O1 &#123;
  name: string
&#125;
let p1: O1 = &#123;
  name: &quot;yuki&quot;,
&#125;

// 继承
interface O2 &#123;
  name: string
&#125;

interface O3 extends O2 &#123;
  age: number
&#125;
let p2: O3 = &#123;
  name: &quot;kusu&quot;,
  age: 12,
&#125;

// 接口合并
interface O4 &#123;
  name: string
&#125;

interface O4 &#123;
  age: number
&#125;

let p3: O4 = &#123;
  name: &quot;ku&quot;,
  age: 12,
&#125;

// type异同
// type不能合并,interface可以
type T2 = number
type T2 = number

interface I1 &#123;
  name: string
&#125;
interface I1 &#123;
  age: number
&#125;

// type不能继承,interface可以
// type实现继承,需要用&amp;交叉类型
type T3 = &#123; age: number &#125;
type T4 = T3 &amp; &#123;
  name: string
&#125;
let p4: T4 = &#123;
  name: &#39;huko&#39;
  ,age: 12
&#125;

// type不能用this,interface可以
// 正确
interface Foo &#123;
  add(num: number): this;
&#125;
// 报错
type Foo = &#123;
  add(num: number): this;
&#125;;

// type可以用于表示任何类型,interface只能用于表示对象类型
type T1 = number

// type可以包含属性映射,interface不行
interface Point &#123;
  x: number;
  y: number;
&#125;

// 正确
type PointCopy1 = &#123;
  [Key in keyof Point]: Point[Key];
&#125;;

// 报错
interface PointCopy2 &#123;
  [Key in keyof Point]: Point[Key];
&#125;;

// type可以扩展原始类型,interface不行
// 正确
type MyStr = string &amp; &#123;
  type: &quot;new&quot;;
&#125;;

// 报错
interface MyStr extends string &#123;
  type: &quot;new&quot;;
&#125;

// type可以表达某些复杂类型,interface不行
type A = &#123;
  /* ... */
&#125;;
type B = &#123;
  /* ... */
&#125;;

type AorB = A | B;
type AorBwithName = AorB &amp; &#123;
  name: string;
&#125;;
</code></pre>
<p>综上所述，如果有复杂的类型运算，那么没有其他选择只能使用type；一般情况下,interface灵活性比较高，便于扩充类型或自动合并，建议优先使用。<br>核心原则是：对外暴露的公共类型用 interface（语义清晰），内部复杂类型逻辑用 type（灵活性高）。<br><img src="https://gitee.com/zhjrcc/blog-images/raw/master/20251221161115.png"><br><img src="https://gitee.com/zhjrcc/blog-images/raw/master/20251221161140.png"></p>
<h2 id="Typescript的类"><a href="#Typescript的类" class="headerlink" title="Typescript的类"></a>Typescript的类</h2><pre><code class="js">// 1.基本用法, class作为实例类型,描述实例类型
class Person1 &#123;
  name: string
  age: number
  constructor(name: string, age: number) &#123;
    this.name = name
    this.age = age
  &#125;
&#125;
const p1: Person1 = new Person1(&quot;jack&quot;, 48)

// class作为一个类使用,其实就是一个构造函数
function createPerson(fn: typeof Person1, name: string, age: number): Person1 &#123;
  return new fn(name, age)
&#125;

function createPerson1(
  fn: new (name: string, age: number) =&gt; Person1,
  name: string,
  age: number
) &#123;
  return new fn(name, age)
&#125;

// 2. 类的interface接口
interface Country &#123;
  name: string
  capital: string
&#125;
// 或者
type Country = &#123;
  name: string
  capital: string
&#125;

class MyCountry implements Country &#123;
  name = &quot;&quot;
  capital = &quot;&quot;
&#125;

// 类的继承
class A &#123;
  greet() &#123;
    console.log(&quot;Hello, world!&quot;)
  &#125;
&#125;

class B extends A &#123;&#125;

const b = new B()
b.greet() // &quot;Hello, world!&quot;
</code></pre>
<p class="backHome"><span></span><a href="/">Back</a><span>↶</span></p></div><script src="/js/highlight.min.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>