<!DOCTYPE html><html lang="zh-CN"><head><title>Typescript</title><meta name="referrer" content="no-referrer"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="icon" href="https://gitee.com/zhjrcc/blog-images/raw/master/favicon.ico?v=2"><link rel="stylesheet" href="/css/post.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="inner"><h1>Typescript</h1><div class="time">First published 2025-12-16</div><div class="updatedTime">Modified 2025-12-16</div><p class="backHome"><span></span><a href="/">Back</a><span>↶</span></p><meta name="referrer" content="no-referrer">

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>1.类型声明</p>
<pre><code class="js">let a: number = 1
function add(a: number, b: number): number &#123;
  return a + b
&#125;
</code></pre>
<p>2.类型推断<br>函数结果自动推断为一个 number</p>
<pre><code class="js">let add(a: number ,b: number) &#123;
  return a + b
&#125;
</code></pre>
<p>3.Typescript编译<br>npx tsc xx.ts,将ts文件编译成js文件，该命令可以添加一些参数，也可以在当前目录在床见一个tsconfig.json，在这个文件中填入相关的参数，执行该命令时就会依照配置执行。</p>
<p>4.值与类型<br>typescript处理的是类型，javascript处理的是值</p>
<p>5.Typescript Playground<br>Typescript官方的在线TS编辑器，可自动生成JS</p>
<p>6.TSC编译器<br>TS官方的编译器，npm i typescript</p>
<p>7.TS-NODE<br>直接在终端中执行TS文件，不需要编译JS再执行。</p>
<h2 id="any-unknown-never"><a href="#any-unknown-never" class="headerlink" title="any unknown never"></a>any unknown never</h2><p>1.any<br>表示任何类型，any类型可以被赋值为任何类型,any类型可以赋值给任何类型。</p>
<p>2.unknown<br>表示未知类型，unknown类型可以被赋值为任何类型，但unknown类型不能赋值给任何类型，除非它通过类型断言或类型守卫被缩小为具体类型。unknown可以被认为是安全版本的any类型。</p>
<p>3.never<br>表示一个空类型，never类型可以赋值给任何类型,但never类型不能被赋值为任何类型。never可以被认为是unknown的对立面。</p>
<h2 id="TypeScript的类型系统"><a href="#TypeScript的类型系统" class="headerlink" title="TypeScript的类型系统"></a>TypeScript的类型系统</h2><p>1.基本类型<br>number,string,boolean,symbol,object,null,undefined,bigint</p>
<p>2.包装对象类型<br>number,string,boolean都有各自的包装对象Number,String,Boolean。为此，TS也给出了类型Number,String,Boolean。包装对象类型包含了基本类型，也就是说，Number类型相当于type T &#x3D; Number | number.</p>
<p>3.Object与object<br>跟包装对象同理，object表示我们日常开发用到的一般对象(数组，对象，函数)，Object则包含JS所有广义的对象（包含了包装对象），因此Object类型可以表示所有JS的对象，除了特殊的null和undefined.</p>
<p>4.undefined和null<br>undefined和null类型都分别只有一个值，就是它们本身，在严格模式下(strict:true或者strictNullChecks:true),直接将undefined或null赋值给一个变量，会自动将类型定义为undefined或null，如果不是严格模式下，则会隐式将类型定义为any。</p>
<p>5.值类型<br>TS中，可以将值作为一种类型.<code>let b:1=2</code>会报错，因为b的类型是1，值只能为1。number是这种数值类型的父类型，<code>let a=1;let b:number = a</code>这样设置是没问题的。同理，string,boolean等其他基本类型也是各自值类型的父类型。</p>
<p>6.联合类型<br>联合类型就是多个类型组合在一起，它的值是这个组合中其中的一个类型，比如<code>type T = number | string</code>，那么T类型就表示值类型可以数字或者字符串。</p>
<p>7.交叉类型<br>交叉类型就是多个类型组合在一起，它的值必须同时符合组合中所有的类型，比如<code>type T = number &amp; string</code>，那么T类型就表示值类型必须是数字也是字符串，那就相当于是never空类型了，因为没有任何一个值能同时满足这个条件。</p>
<p>8.type命令<br>可以通过使用type命令来创建类型别名,比如<code>type Name = string; type Age = number; let name:Name = &#39;aa&#39;; let age:Age = 18</code>.</p>
<p>9.typeof运算符<br>typeof type，返回一个TS类型，注意，这个命令的操作值是一个值，但返回的是该值的类型，而不是字符串。这个跟JS中的typeof是有区别的，JS的typeof返回的是该值的类型的一个字符串，比如typeof 1，得到的就是’number’.</p>
<pre><code class="js">// TS中的typeof
let a:number = 1;
let b:typeof a = &#39;adsf&#39;; // 报错，b的类型是a的number类型

console.log(typeof a) //输出number
</code></pre>
<p>10.块级类型声明<br>使用type命令声明类型时，它的作用域是块级作用域。</p>
<p>11.类型的兼容<br>子类型可以用于所有使用父类型的场合。反之，则不行。</p>
<pre><code class="js">let a: 1 = 1
// 不报错
let b: number = a

// 报错，不能将number类型分配给1类型
a = b
</code></pre>
<h2 id="TypeScript的数组类型"><a href="#TypeScript的数组类型" class="headerlink" title="TypeScript的数组类型"></a>TypeScript的数组类型</h2><p>Typescript规定数组的所有成员的类型必须相同，数量可以不确定。<br>1.数组类型声明方式</p>
<pre><code class="js">let arr:number[] = [1,2]
let arr:(number|string)[] = [1,&#39;test&#39;]

let arr:Array&lt;number&gt; = [1,2]
let arr:Array&lt;number|string&gt; = [1,&#39;test&#39;]
</code></pre>
<p>2.数组的类型推断</p>
<pre><code class="js">// arr会被类型推断为是any[]
let arr = []
// arr类型推断更新为number[]
arr.push(1)
// arr类型推断更新为(number|string)[]
arr.push(&#39;test&#39;)
// 只有初始值为空数组会这样进行推断，如果不为空数组则不会更新类型
</code></pre>
<p>3.只读数组<br>只读数组不能做任何修改，是数组的父类型</p>
<pre><code class="js">let arr1:number[] = [1,2]
let arr2: readonly number[] = arr1

let arr3: ReadonlyArray&lt;number&gt; = arr1
let arr4: Readonly&lt;number[]&gt; = arr1
let arr5 = [1, 2] as const
</code></pre>
<p>4.多维数组<br>多维数组的类型定义是给最底层的成员</p>
<pre><code class="js">let arr: number[][] = [[1,2],[3,4,5]]
</code></pre>
<p class="backHome"><span></span><a href="/">Back</a><span>↶</span></p></div><script src="/js/highlight.min.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>