<!DOCTYPE html><html lang="zh-CN"><head><title>备忘录</title><meta name="referrer" content="no-referrer"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="icon" href="https://gitee.com/zhjrcc/blog-images/raw/master/favicon.ico?v=2"><link rel="stylesheet" href="/css/post.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="inner"><h1>备忘录</h1><meta name="referrer" content="no-referrer">

<h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><p>插入：<code>i</code><br>保存文件并退出：<code>:wq</code><br>不保存退出：<code>:q!</code></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><meta http-equiv="X-UA-Compatible" content="IE=edge"></h2><p>X-UA-Compatible是設置IE兼容模式用的，也就是选择页面应呈现为哪个版本的Internet Explorer，<br>比如当前的标准是：<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code><br>但现在，因为现代浏览器大多都更新了，并非一定要在网页中添加这个兼容模式。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><meta name="viewport"></h2><p>viewport tag 的定義只對mobile device有用，用來控制 mobile device 顯示網頁內容時的一些設定。</p>
<pre><code class="html">// 指定螢幕寬度為裝置寬度，畫面載入初始縮放比例 100%
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; &gt;
// 以下兩種設定都可以防止使用者做畫面縮放，將畫面鎖在縮放比例 100%
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1&quot; &gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot;&gt;
</code></pre>
<h2 id="解决浏览器自动加载favicon"><a href="#解决浏览器自动加载favicon" class="headerlink" title="解决浏览器自动加载favicon"></a>解决浏览器自动加载favicon</h2><pre><code class="html">&lt;link rel=&quot;icon&quot; href=&quot;data:,&quot;&gt;
</code></pre>
<h2 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h2><pre><code class="javascript">// 函数声明会“提升”到当前作用域的顶层，因此在函数声明之前就可以使用函数
sum(1,2);
function sum(x, y) &#123;return x + y&#125;;

// 函数表达式不会“提升”，在函数表达式之前调用该函数会引发错误
// 如果将函数对象分配给var变量，则引发“类型错误” TypeError: sum is not a function
// 如果将函数对象分配给let变量，则引发“引用错误” Reference: sum is not defined
sum(1, 2);
// let
var sum = function (x, y) &#123;return x + y&#125;
</code></pre>
<h2 id="amp-amp-和-另一种用法"><a href="#amp-amp-和-另一种用法" class="headerlink" title="&amp;&amp;和||另一种用法"></a>&amp;&amp;和||另一种用法</h2><pre><code class="javascript">// &amp;&amp; 和 || 都是短路行为（short circuiing）
// &amp;&amp; 流行用作条件执行，相当于if，这里只有当a===b才会执行stop
a===b &amp;&amp; stop()
// || 流行用作条件变量赋值，当b是true时，执行a=b，否则a=[]
a = b || [];
</code></pre>
<h2 id="argument和parameter"><a href="#argument和parameter" class="headerlink" title="argument和parameter"></a>argument和parameter</h2><p>parameter指函数定义中的参数，也就是形式参数；argument指函数被调用时的参数，也就是实际参数。</p>
<h2 id="解构赋值：将实参解构为单个形参"><a href="#解构赋值：将实参解构为单个形参" class="headerlink" title="解构赋值：将实参解构为单个形参"></a>解构赋值：将实参解构为单个形参</h2><pre><code class="javascript">const vectorAdd = ([x1, y1], [x2, y2]) =&gt; [x1 + x2, y1 + y2];
const result = vectorAdd([1, 2], [3, 4]);
console.log(result); // [4, 6]
</code></pre>
<h2 id="…扩展运算符和…rest剩余函数参数"><a href="#…扩展运算符和…rest剩余函数参数" class="headerlink" title="…扩展运算符和…rest剩余函数参数"></a>…扩展运算符和…rest剩余函数参数</h2><pre><code class="javascript">// 都是三个...，但用法是完全不同的
// rest剩余函数参数用在函数的形式参数上，把多余的参数都加入到rest数组中
function([x, y, ...rest1], ...rest2) &#123;
// 扩展运算符用在数组或者任何可迭代对象上，进行展开
  return [x+y, ...rest1, ...coords]
&#125;
</code></pre>
<h2 id="exports和module-exports区别"><a href="#exports和module-exports区别" class="headerlink" title="exports和module.exports区别"></a>exports和module.exports区别</h2><p><code>exports</code>只是<code>module.exports</code>的一个引用，在评估模块之前被分配 module.exports 的值。<br>与任何变量一样，如果将新值分配给 exports，则它就不再绑定到 module.exports。<br><code>require(module)</code>的返回值是module.exports而不是exports。<br>惯例用法：<br>将多个变量或者函数导出，则使用exports；<br>将单个变量，函数，类，导出，则使用module.exports；</p>
<pre><code class="javascript">// exports导出多个函数
// 此时，相当于是module.exports的快捷方式
exports.add = (x, y) =&gt; x + y;
exports.subtract (x, y) =&gt; x - y;

// module.exports导出一个类
// 此时，不能使用exports，否则只会覆盖exports，让其不再绑定到module.exports
class MyClass &#123;&#125;
module.exports = MyClass;
// 通常，当module.exports被完全替换时，也会将exports重新分配，但这不是强制性的
module.exports = exports = Myclass;

// 为了实现module也能一次性导出多个变量或者函数
// 可以将需要导出的变量或者函数都放到一个对象中，替换掉module.exports就行
let a = 1;
let b = 2;
let add = (a + b) =&gt; &#123;
  return a + b;
&#125;
module.exports = &#123; a, b, add &#125;
</code></pre>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><h2 id="补码（英语：2’s-complement）是一种用二进制表示有符号数的方法。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。正数和0就是该数字本身再补上最高比特0，正数不需要使用补码反转。负数的补码则是将其对应正数按位取反再加1。正数的最高比特恒为0。补码数字的负数，最高比特恒为1。-0011-3-1111-1"><a href="#补码（英语：2’s-complement）是一种用二进制表示有符号数的方法。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。正数和0就是该数字本身再补上最高比特0，正数不需要使用补码反转。负数的补码则是将其对应正数按位取反再加1。正数的最高比特恒为0。补码数字的负数，最高比特恒为1。-0011-3-1111-1" class="headerlink" title="补码（英语：2’s complement）是一种用二进制表示有符号数的方法。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。正数和0就是该数字本身再补上最高比特0，正数不需要使用补码反转。负数的补码则是将其对应正数按位取反再加1。正数的最高比特恒为0。补码数字的负数，最高比特恒为1。    0011 (3)  + 1111 (-1)"></a>补码（英语：2’s complement）是一种用二进制表示有符号数的方法。<br>补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。<br><strong>正数和0就是该数字本身再补上最高比特0，正数不需要使用补码反转。负数的补码则是将其对应正数按位取反再加1。</strong><br><img src="https://unpkg.com/gitimages/2023-02-03-22-35-24.png"><br>正数的最高比特恒为0。<br>补码数字的负数，最高比特恒为1。<br>    0011 (3)<br>  + 1111 (-1)</h2><p>   10010 (2)</p>
<p>补码计算规则：在计算二进制数字的补码时，会将数字进行比特反相运算，再将结果加1。<br>简单说，X（无论X是正负数）的补码就是-X。因此可以得出公式，X的补码&#x3D;-X&#x3D;按位非~+1</p>
<h2 id="Buffer和Cache的区别"><a href="#Buffer和Cache的区别" class="headerlink" title="Buffer和Cache的区别"></a>Buffer和Cache的区别</h2><p>Buffer 的存在原因是生产者和消费者对资源的生产&#x2F;消费的效率不一致，提供一个缓冲区，让生产者以任何效率把资源放到缓冲区再让消费者以任何的效率消费。<br>Buffer主要用于流量整形，把突发的大数量较小规模的 I&#x2F;O， 放到缓冲区，整理成平稳的小数量较大规模的 I&#x2F;O，以<strong>减少响应次数</strong>。<br>比如，从网络下载文件，下载速度是随机的（大数量小规模的数据或者小数量小规模），设定硬盘的最小写入block是2Mb。可以先把下载到的写入buffer，直到满了2Mb，再把它写入硬盘中，而不是直接一点一点的写入硬盘中，不需要每次都访问硬盘，减少响应次数。</p>
<p>Cache是为了弥补高速设备和低速设备的鸿沟而引入的中间层，起到加快访问速度的作用。</p>
<h2 id="Intl-Collator按拼音排序"><a href="#Intl-Collator按拼音排序" class="headerlink" title="Intl.Collator按拼音排序"></a>Intl.Collator按拼音排序</h2><pre><code class="javascript">// zh-Hans就是简体中文的缩写，这种缩写称为‘BCP-47’语言标签
let pinyinSort = new Intl.Collator(&#39;zh-Hans-u-co-pinyin&#39;).compare;
// 或者通过option对象中的collation属性添加pinyin排序,其中第一个区域设置参数是必须的
pinyinSort = new Intl.Collator(&#39;zh-Hans&#39;, &#123;
  collation:&#39;pinyin&#39;
&#125;).compare;
let array = [&#39;在&#39;, &#39;我&#39;,&#39;了&#39;,&#39;饿&#39;,&#39;好&#39;];
array.sort(pinyinSort);
// [&#39;饿&#39;, &#39;好&#39;, &#39;了&#39;, &#39;我&#39;, &#39;在&#39;]
// E H L W Z
</code></pre>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>理解：Promise就是一个容器，里面保存着某个未来才会结束的事件（异步操作）的结果。<br>注意：<strong>一旦创建一个Promise，其中的异步操作就会开始执行。这就是为什么通常都会在函数中返回一个Promise，而不是直接创建一个Promise，在需要Promise再调用函数。</strong><br>示例：</p>
<pre><code class="js">const pFun = (time) =&gt; &#123;
  return () =&gt;
    new Promise((resolve, reject) =&gt; &#123;
      if (0 &lt; time &lt;= 50000) &#123;
        setTimeout(()=&gt; &#123;
          resolve(&#39;此次时间间隔是&#39; + time + &#39;ms&#39;)
        &#125;, time)
      &#125; else &#123;
        reject(&#39;超时&#39;)
      &#125;
    &#125;);
&#125;;

// 这是一个函数数组，pFun()返回的是一个函数，数组的每个元素都是一个函数，
// 每个函数返回的是一个promise
pFunArr = [pFun(2000), pFun(1000), pFun(500)]

// 使用async/await，按顺序执行每一个Promise
async function asyncPromise() &#123;
  for(const req of pFunArr) &#123;
    const result = await req();
    console.log(result)
  &#125;
&#125;
asyncPromise()
</code></pre>
<p>上面例子很好说明了这一点:<br>为什么不直接return Prmise，而是return一个函数，再通过函数return promise？<br>原因是，如果直接return Promise，则数组中每一个元素都是一个Promise，而此时数组中所有的Promise中的异步操作都会同时立刻执行，而并非按顺序执行每一个Promise。<br>下面是错误的示例：</p>
<pre><code class="js">const pFun = (time) =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
      if (0 &lt; time &lt;= 50000) &#123;
        setTimeout(()=&gt; &#123;
          resolve(&#39;此次时间间隔是&#39; + time + &#39;ms&#39;)
        &#125;, time)
      &#125; else &#123;
        reject(&#39;超时&#39;)
      &#125;
    &#125;);
&#125;;

// 这是一个函数数组，pFun()返回的是一个函数，数组的每个元素都是一个函数，
// 每个函数返回的是一个promise
pFunArr = [pFun(1000), pFun(4000), pFun(2000)]

// 使用async/await，按顺序执行每一个Promise
async function asyncPromise() &#123;
  for(const req of pFunArr) &#123;
    const result = await req;
    console.log(result)
  &#125;
&#125;
asyncPromise()
</code></pre>
<h2 id="解决-MacOS-12-Monterey-端口-5000-被占用"><a href="#解决-MacOS-12-Monterey-端口-5000-被占用" class="headerlink" title="解决 MacOS 12 Monterey 端口 5000 被占用"></a>解决 MacOS 12 Monterey 端口 5000 被占用</h2><p>macOS 12加入的 AirPlay（隔空播放） 占用了 5000 端口。<br>使用<code>lsof -i :5000</code>查看端口占用情况，使用<code>kill -9 PID</code>来终结该占用情况。<br>但由于是系统本身占用，所以即使终结也一样会自动重启，如果一定要使用5000端口，则打开系统偏好-共享，点掉“隔空播放接收器”，问题解决。但最好还是使用其他端口，没必要一定要用5000。</p>
<h2 id="async-x2F-await捕获错误"><a href="#async-x2F-await捕获错误" class="headerlink" title="async&#x2F;await捕获错误"></a>async&#x2F;await捕获错误</h2><p>async函数在Express中必须使用try&#x2F;catch捕获错误，并且在catch(e)中使用next(e),否则程序无法捕获错误，导致崩溃。<br>如果不是async函数，则无需catch，express也能处理，throw 错误，只要在express中添加错误处理中间件，express也能将错误信息传递到错误处理中间件。<br>例如：</p>
<pre><code class="js">const addContact = async (req, res, next) =&gt; &#123;
  try &#123;
    const &#123; name, phone &#125; = req.body;
    if (name &amp;&amp; phone) &#123;
      res.status(201).json(&#123; message: `创建联系方式$&#123;name&#125;` &#125;);
    &#125; else &#123;
      res.status(400);
      throw new Error(&quot;所有字段都需要填充&quot;);
    &#125;
  &#125; catch (e) &#123;
    next(e);
  &#125;
&#125;;
</code></pre>
<p>在Express中有一个中间件专门处理这种，<code>express-async-handler</code>.</p>
<h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>通过brew install安装的包，在&#x2F;usr&#x2F;local&#x2F;cellar中。<br>重启<br>brew services restart mongodb-community<br>启动<br>brew services start mongodb-community<br>停止<br>brew services stop mongodb-community<br>MongoNetworkError: connect ECONNREFUSED 127.0.0.1:27017连接失败： sudo rm -rf &#x2F;tmp&#x2F;mongodb-27017.sock</p>
<h2 id="ORM和ODM"><a href="#ORM和ODM" class="headerlink" title="ORM和ODM"></a>ORM和ODM</h2><p>object relational Mapping 对象关系映射，object document mapping 对象文档映射<br>都是用于在编程语言中的对象模型和数据库中的数据模型之间进行映射的工具。<br>常见的ORM库：Sequelize，TypeORM<br>常见的ODM库：Mongoose</p>
<h2 id="mongodb添加用户"><a href="#mongodb添加用户" class="headerlink" title="mongodb添加用户"></a>mongodb添加用户</h2><p>db.createUser({user: “root”,pwd: “113647”,roles:[“root”]})<br>mongodb配置路径 &#x2F;usr&#x2F;local&#x2F;etc vim mongod.conf<br>验证：<br>security:<br>    authorization: enabled</p>
<p>mongoDB，shell界面<br>切换到admin数据库 , use admin,再db.auth(“root”,”113647”)</p>
<h2 id="yt-dlp"><a href="#yt-dlp" class="headerlink" title="yt-dlp"></a>yt-dlp</h2><p>原始<br>yt-dlp -f “bestvideo+bestaudio” –write-auto-sub –convert-subs&#x3D;ass –sub-lang “zh-Hans,en” –embed-sub –write-thumbnail –convert-thumbnail png –embed-thumbnail URL</p>
<p>默认<br>yt-dlp -f “bestvideo+bestaudio” –write-auto-sub –sub-lang “zh-Hans,en” –embed-sub <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=M0dAK6IQsSk">https://www.youtube.com/watch?v=M0dAK6IQsSk</a></p>
<p>原版<br>yt-dlp -f “bestvideo+bestaudio” <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=C-Gmx9ezh5g">https://www.youtube.com/watch?v=C-Gmx9ezh5g</a></p>
<p>仅仅下载字幕<br>yt-dlp –write-auto-sub –sub-lang “zh-Hans,en” –skip-download <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=lAFbKzO-fss">https://www.youtube.com/watch?v=lAFbKzO-fss</a></p>
<p>仅仅下载音频<br>yt-dlp -f bestaudio –extract-audio –audio-format mp3 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch/?v%5C=1R47EQrxgfw">https://www.youtube.com/watch\?v\=1R47EQrxgfw</a></p>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p><strong>HTTP 状态码分类</strong></p>
<p>HTTP 状态码分为五类，每类都有不同的含义：</p>
<ul>
<li><p><strong>1xx Informational</strong>：表示信息性响应，表示请求已收到并正在处理中。例如：</p>
<ul>
<li>100 Continue：表示客户端应继续发送请求。</li>
<li>101 Switching Protocols：表示服务器已切换到使用不同的协议。</li>
</ul>
</li>
<li><p><strong>2xx Success</strong>：表示成功响应，表示请求已成功处理。例如：</p>
<ul>
<li>200 OK：表示请求成功，服务器已成功处理请求。</li>
<li>201 Created：表示请求已成功创建新资源。</li>
<li>204 No Content：表示请求已成功处理，但没有返回任何内容。</li>
</ul>
</li>
<li><p><strong>3xx Redirection</strong>：表示重定向响应，表示客户端需要采取进一步的行动才能完成请求。例如：</p>
<ul>
<li>301 Moved Permanently：表示请求的资源已永久移动到新位置。</li>
<li>302 Found：表示请求的资源已临时移动到新位置。</li>
<li>307 Temporary Redirect：表示请求的资源已临时重定向到新位置。</li>
</ul>
</li>
<li><p><strong>4xx Client Error</strong>：表示客户端错误响应，表示请求有语法错误或无法被服务器理解。例如：</p>
<ul>
<li>400 Bad Request：表示请求有语法错误或无法被服务器理解。</li>
<li>401 Unauthorized：表示请求未经授权。</li>
<li>403 Forbidden：表示服务器拒绝处理请求。</li>
<li>404 Not Found：表示请求的资源不存在。</li>
</ul>
</li>
<li><p><strong>5xx Server Error</strong>：表示服务器错误响应，表示服务器在处理请求时遇到了意外情况。例如：</p>
<ul>
<li>500 Internal Server Error：表示服务器在处理请求时遇到了意外情况。</li>
<li>502 Bad Gateway：表示服务器作为网关或代理时收到了无效的响应。</li>
<li>503 Service Unavailable：表示服务器暂时不可用。</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<p>HTTP 状态码在 Web 开发和故障排除中有很多使用场景，以下是一些最常见的场景：</p>
<ul>
<li><strong>诊断错误</strong>：HTTP 状态码可以帮助诊断 Web 应用程序中的错误。例如，404 状态码表示请求的资源不存在，而 500 状态码表示服务器在处理请求时遇到了意外错误。</li>
<li><strong>重定向用户</strong>：HTTP 状态码可以用来重定向用户到不同的 URL。例如，301 状态码表示请求的资源已永久移动到新位置。</li>
<li><strong>缓存响应</strong>：HTTP 状态码可以用来控制浏览器如何缓存响应。例如，200 状态码表示响应可以被浏览器缓存，而 304 状态码表示响应自上次请求以来未被修改。</li>
<li><strong>身份验证</strong>：HTTP 状态码可以用来验证用户身份。例如，401 状态码表示请求未经授权，而 403 状态码表示服务器拒绝处理请求。</li>
<li><strong>负载平衡</strong>：HTTP 状态码可以用来在多台服务器之间进行负载平衡。例如，503 状态码表示服务器暂时不可用。</li>
</ul>
<p>通过正确使用 HTTP 状态码，开发人员可以创建更健壮、用户友好的 Web 应用程序。</p>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p>REST API（Representational State Transfer API）是一种遵循 REST（表述性状态转移）架构风格的应用程序编程接口（API）。REST API 的设计原则包括：</p>
<ul>
<li><strong>无状态性</strong>：REST API 的请求和响应之间没有状态。每个请求都包含所有必要的信息，服务器不会存储任何与请求相关的状态。</li>
<li><strong>可缓存性</strong>：REST API 的响应可以被客户端缓存。这可以提高性能，减少服务器的负载。</li>
<li><strong>统一接口</strong>：REST API 使用统一的接口来操作资源。这使得客户端可以轻松地与 API 交互。</li>
<li><strong>按需代码</strong>：REST API 的客户端可以按需下载代码。这可以减小客户端的大小，并允许客户端在需要时获取最新代码。</li>
</ul>
<p>REST API 通常使用 HTTP 作为通信协议，并使用 JSON 或 XML 等格式传输数据。REST API 的常见操作包括：</p>
<ul>
<li><strong>GET</strong>：获取资源。</li>
<li><strong>POST</strong>：创建资源。</li>
<li><strong>PUT</strong>：更新资源。</li>
<li><strong>DELETE</strong>：删除资源。<br>a o<br><strong>理解 REST API 的关键</strong></li>
</ul>
<p>要理解 REST API，有几个关键概念需要掌握：</p>
<ul>
<li><strong>资源</strong>：REST API 操作的对象。例如，用户、产品或订单。</li>
<li><strong>URI</strong>：用于标识资源的统一资源标识符。</li>
<li><strong>HTTP 方法</strong>：用于指定请求类型的 HTTP 方法（如 GET、POST、PUT、DELETE）。</li>
<li><strong>表示</strong>：资源的具体表现形式，例如 JSON 或 XML。</li>
</ul>
<p><strong>REST API 的优点</strong></p>
<p>REST API 具有许多优点，包括：</p>
<ul>
<li><strong>可扩展性</strong>：REST API 易于扩展，可以轻松添加新功能和资源。</li>
<li><strong>灵活性</strong>：REST API 可以使用各种编程语言和平台构建。</li>
<li><strong>可移植性</strong>：REST API 可以轻松地部署到不同的服务器和环境。</li>
<li><strong>易于使用</strong>：REST API 易于理解和使用，客户端可以轻松地与之交互。</li>
</ul>
<p>REST API 在当今的 Web 开发中被广泛使用，是构建可扩展、灵活且易于使用的应用程序的理想选择。</p>
<h2 id="PUT和Patch区别"><a href="#PUT和Patch区别" class="headerlink" title="PUT和Patch区别"></a>PUT和Patch区别</h2><p><strong>PUT</strong> 和 <strong>PATCH</strong> 都是 HTTP 请求方法，用于修改服务器上的资源。然而，它们在语义和使用上有细微的差别：</p>
<p><strong>PUT</strong></p>
<ul>
<li>用于替换服务器上的整个资源。</li>
<li>请求体应该包含资源的完整表示。</li>
<li>如果资源不存在，则创建一个新资源。</li>
<li>如果资源已经存在，则用请求体中的表示替换它。</li>
</ul>
<p><strong>PATCH</strong></p>
<ul>
<li>用于对服务器上的现有资源进行部分更新。</li>
<li>请求体应该只包含要更新的资源属性。</li>
<li>如果资源不存在，则返回错误。</li>
<li>如果资源已经存在，则使用请求体中的属性更新它。</li>
</ul>
<p><strong>什么时候使用 PUT 和 PATCH</strong></p>
<p>一般来说，<strong>PUT</strong> 用于替换整个资源，而 <strong>PATCH</strong> 用于更新资源的部分属性。</p>
<p>以下是一些使用 PUT 和 PATCH 的示例：</p>
<ul>
<li><strong>PUT</strong>：更新用户的整个个人资料，包括姓名、电子邮件和地址。</li>
<li><strong>PATCH</strong>：更新用户的姓名或电子邮件地址，而无需更改其他属性。</li>
</ul>
<p>以下是一些使用 PUT 和 PATCH 的优点和缺点：</p>
<p><strong>PUT</strong></p>
<ul>
<li><strong>优点</strong>：简单易用，因为你只需要提供资源的完整表示。</li>
<li><strong>缺点</strong>：如果只想更新资源的部分属性，则需要提供整个资源的表示，这可能会很低效。</li>
</ul>
<p><strong>PATCH</strong></p>
<ul>
<li><strong>优点</strong>：高效，因为你只需要提供要更新的属性。</li>
<li><strong>缺点</strong>：更复杂，因为你需要了解要更新的属性的 JSON 表示。</li>
</ul>
<p>总体而言，PUT 和 PATCH 都是修改服务器上资源的有效方法。具体使用哪种方法取决于你要更新的资源的性质和你要进行的更改的类型。</p>
<h2 id="git返回到某个commit"><a href="#git返回到某个commit" class="headerlink" title="git返回到某个commit"></a>git返回到某个commit</h2><p>要返回到某个提交，可以使用 <code>git reset</code> 命令。该命令的语法如下：</p>
<pre><code>git reset [--hard | --soft | --mixed] [commit-ish]
</code></pre>
<p>其中：</p>
<ul>
<li><code>--hard</code>：将当前工作目录重置为指定的提交，并丢弃所有未提交的更改。</li>
<li><code>--soft</code>：将当前工作目录重置为指定的提交，但保留所有未提交的更改。</li>
<li><code>--mixed</code>（默认）：将当前工作目录重置为指定的提交，但保留已暂存的更改。</li>
<li><code>commit-ish</code>：要重置到的提交的引用，可以是提交哈希、分支名称或标签。</li>
</ul>
<p>例如，要将当前工作目录重置到名为 <code>main</code> 的分支上的最新提交，可以使用以下命令：</p>
<pre><code>git reset --hard main
</code></pre>
<p>要将当前工作目录重置到特定提交哈希，可以使用以下命令：</p>
<pre><code>git reset --hard 1234567890abcdef
</code></pre>
<p><strong>警告：</strong> 使用 <code>git reset --hard</code> 时要小心，因为它会丢弃所有未提交的更改。在使用此命令之前，请确保已提交或暂存了所有重要的更改。</p>
<h2 id="git重置分支之后不能重新返回吗"><a href="#git重置分支之后不能重新返回吗" class="headerlink" title="git重置分支之后不能重新返回吗"></a>git重置分支之后不能重新返回吗</h2><p>使用 <code>git reset --hard</code> 命令重置分支后，<strong>不能</strong> 直接重新返回到该分支的先前状态。这是因为 <code>--hard</code> 选项会将当前工作目录重置到指定的提交，并<strong>丢弃所有未提交的更改</strong>。</p>
<p>但是，你可以使用以下方法之一恢复丢失的更改：</p>
<ul>
<li><strong>从备份中恢复：</strong> 如果你在重置分支之前已备份了代码，则可以从备份中恢复丢失的更改。</li>
<li><strong>使用 reflog：</strong> Git 维护一个名为 reflog 的日志，其中记录了所有分支和提交的更改。你可以使用 <code>git reflog</code> 命令查看 reflog，并使用 <code>git reset</code> 命令将分支重置到 reflog 中的先前状态。例如：</li>
</ul>
<pre><code>git reflog
git reset --hard HEAD@&#123;1&#125;
</code></pre>
<p>此命令将分支重置到最近一次提交之前的状态。</p>
<p>请注意，使用 <code>git reset --hard</code> 命令时要小心，因为它会丢弃所有未提交的更改。在使用此命令之前，请确保已提交或暂存了所有重要的更改。</p>
<h2 id="如何给某个提交打标签"><a href="#如何给某个提交打标签" class="headerlink" title="如何给某个提交打标签"></a>如何给某个提交打标签</h2><p>要给某个提交打标签，可以使用 <code>git tag</code> 命令。该命令的语法如下：</p>
<pre><code>git tag [选项] &lt;标签名&gt; [提交对象]
</code></pre>
<p>其中：</p>
<ul>
<li><code>&lt;标签名&gt;</code>：要创建的标签的名称。</li>
<li><code>[提交对象]</code>：要标记的提交的引用，可以是提交哈希、分支名称或标签。</li>
</ul>
<p>例如，要给 HEAD 所指向的最新提交打上名为 <code>v1.0</code> 的标签，可以使用以下命令：</p>
<pre><code>git tag v1.0
</code></pre>
<p>要给特定提交哈希打标签，可以使用以下命令：</p>
<pre><code>git tag v1.0 1234567890abcdef
</code></pre>
<p>你还可以使用 <code>-a</code> 选项创建带注释的标签。带注释的标签包含指向提交的引用以及标签消息。例如：</p>
<pre><code>git tag -a v1.0 -m &quot;This is version 1.0 of the project.&quot;
</code></pre>
<p>此命令将创建一个名为 <code>v1.0</code> 的带注释的标签，并带有消息 “This is version 1.0 of the project.”。</p>
<p>要查看所有标签，可以使用 <code>git tag</code> 命令：</p>
<pre><code>git tag
</code></pre>
<p>要删除标签，可以使用 <code>git tag -d</code> 命令：</p>
<pre><code>git tag -d v1.0
</code></pre>
<p>请注意，只能删除未推送的标签。要删除已推送的标签，你需要使用 <code>git push --delete</code> 命令。</p>
<p>可以通过标签来返回到这个提交中。</p>
<h2 id="git-commit的同时打上标签"><a href="#git-commit的同时打上标签" class="headerlink" title="git commit的同时打上标签"></a>git commit的同时打上标签</h2><p>在 Git 中，你可以使用 <code>git tag</code> 命令为特定的提交打上标签。要在提交时同时打上标签，你可以执行以下步骤：</p>
<ol>
<li><strong>提交代码</strong>：首先，你需要将代码提交到 Git 仓库中，使用 <code>git add</code> 将要提交的文件添加到暂存区，然后使用 <code>git commit</code> 提交到本地仓库。</li>
</ol>
<pre><code class="bash">git add .
git commit -m &quot;Your commit message&quot;
</code></pre>
<ol start="2">
<li><p><strong>打标签</strong>：在提交代码后，使用 <code>git tag</code> 命令为该提交打上标签。你可以选择打上轻量标签（lightweight tag）或附注标签（annotated tag）。</p>
<ul>
<li><strong>轻量标签</strong>：只是一个指向提交的引用，不包含其他信息。</li>
<li><strong>附注标签</strong>：可以包含额外的信息，如标签名、标签信息、创建者等。</li>
</ul>
</li>
</ol>
<pre><code class="bash"># 轻量标签
git tag tag_name

# 附注标签
git tag -a tag_name -m &quot;Your tag message&quot;
</code></pre>
<p>替换 <code>tag_name</code> 为你想要的标签名，替换 <code>&quot;Your tag message&quot;</code> 为标签信息（仅适用于附注标签）。</p>
<ol start="3">
<li><strong>推送标签到远程仓库</strong>（如果需要）：如果你想在远程仓库中使用这个标签，你需要将标签推送到远程仓库。</li>
</ol>
<pre><code class="bash">git push origin tag_name
</code></pre>
<p>这会将特定标签推送到远程仓库。如果你要推送所有标签，可以使用 <code>--tags</code> 选项：</p>
<pre><code class="bash">git push origin --tags
</code></pre>
<p>以上步骤就是在提交代码时同时打上标签的方法。记得在操作前确认好你的标签命名规范以及是否需要推送标签到远程仓库。</p>
<h2 id="commonjs和es-module区别"><a href="#commonjs和es-module区别" class="headerlink" title="commonjs和es module区别"></a>commonjs和es module区别</h2><p><strong>CommonJS</strong> 和 <strong>ES module</strong> 都是 JavaScript 模块化的方式，但它们在语法、作用域和加载机制上有所不同。</p>
<p><strong>语法</strong></p>
<ul>
<li><strong>CommonJS:</strong> 使用 <code>require()</code> 和 <code>module.exports</code>。</li>
<li><strong>ES module:</strong> 使用 <code>import</code> 和 <code>export</code>。</li>
</ul>
<p><strong>作用域</strong></p>
<ul>
<li><strong>CommonJS:</strong> 模块中的变量和函数在模块作用域中，不会泄漏到全局作用域。</li>
<li><strong>ES module:</strong> 模块中的变量和函数默认处于块级作用域，但可以使用 <code>export</code> 和 <code>import</code> 语句将其导出和导入。</li>
</ul>
<p><strong>加载机制</strong></p>
<ul>
<li><strong>CommonJS:</strong> 使用同步加载，即模块在执行代码之前被加载。</li>
<li><strong>ES module:</strong> 使用异步加载，即模块在代码执行过程中被加载。</li>
</ul>
<p><strong>其他区别</strong></p>
<ul>
<li><strong>CommonJS:</strong> 模块是 CommonJS 规范的对象，具有 <code>exports</code> 和 <code>require</code> 属性。</li>
<li><strong>ES module:</strong> 模块是 JavaScript 对象，具有 <code>default</code> 属性和可选的命名导出。</li>
<li><strong>CommonJS:</strong> 模块中的代码在执行时被求值。</li>
<li><strong>ES module:</strong> 模块中的代码在加载时被求值。</li>
<li><strong>CommonJS:</strong> 模块可以循环引用（依赖），但可能会导致死锁。</li>
<li><strong>ES module:</strong> 模块不能循环引用，因为它们是异步加载的。</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>CommonJS</th>
<th>ES module</th>
</tr>
</thead>
<tbody><tr>
<td>语法</td>
<td>require(), module.exports</td>
<td>import, export</td>
</tr>
<tr>
<td>作用域</td>
<td>模块作用域</td>
<td>块级作用域</td>
</tr>
<tr>
<td>加载机制</td>
<td>同步加载</td>
<td>异步加载</td>
</tr>
<tr>
<td>模块类型</td>
<td>CommonJS 对象</td>
<td>JavaScript 对象</td>
</tr>
<tr>
<td>代码求值</td>
<td>执行时</td>
<td>加载时</td>
</tr>
<tr>
<td>循环引用</td>
<td>允许</td>
<td>不允许</td>
</tr>
</tbody></table>
<h2 id="设置zsh"><a href="#设置zsh" class="headerlink" title="设置zsh"></a>设置zsh</h2><p>vim ~&#x2F;.zshrc</p>
<h2 id="git返回到某个特定的commit"><a href="#git返回到某个特定的commit" class="headerlink" title="git返回到某个特定的commit"></a>git返回到某个特定的commit</h2><p>要返回到 Git 中的某个特定提交，可以使用以下步骤：</p>
<ol>
<li><strong>找到要返回的提交的哈希值。</strong>可以使用以下命令：</li>
</ol>
<pre><code>git log --oneline
</code></pre>
<ol start="2">
<li><strong>重置 HEAD 指针到该提交。</strong>可以使用以下命令：</li>
</ol>
<pre><code>git reset --hard &lt;提交哈希值&gt;
</code></pre>
<p>这将使你的工作目录和暂存区与指定的提交保持一致。</p>
<p><strong>注意：</strong>使用 <code>git reset --hard</code> 时要小心，因为它会丢弃所有未提交的更改。在使用此命令之前，请确保你已经理解了它的工作原理。</p>
<p><strong>另外一种返回到特定提交的方法是使用 <code>git checkout</code> 命令。</strong></p>
<ol>
<li><strong>找到要返回的提交的哈希值。</strong>可以使用以下命令：</li>
</ol>
<pre><code>git log --oneline
</code></pre>
<ol start="2">
<li><strong>检出该提交。</strong>可以使用以下命令：</li>
</ol>
<pre><code>git checkout &lt;提交哈希值&gt;
</code></pre>
<p>这将使你的工作目录与指定的提交保持一致，但不会丢弃任何未提交的更改。</p>
<p><strong>注意：</strong>使用 <code>git checkout</code> 时，它会将 HEAD 指针移动到指定的提交。这与 <code>git reset --hard</code> 不同，后者会将 HEAD 指针和工作目录重置为指定的提交。</p>
<h2 id="export-default-vs-export-const"><a href="#export-default-vs-export-const" class="headerlink" title="export default vs export const"></a>export default vs export const</h2><p><strong>区别</strong></p>
<p><code>export const obj = &#123;age: 1&#125;</code> 和 <code>const obj = &#123;age: 1&#125;\nexport default obj</code> 之间的主要区别在于：</p>
<ul>
<li><p><strong>导出方式：</strong></p>
<ul>
<li><code>export const obj = &#123;age: 1&#125;</code> 使用具名导出，导出一个名为 <code>obj</code> 的变量。</li>
<li><code>const obj = &#123;age: 1&#125;\nexport default obj</code> 使用默认导出，导出 <code>obj</code> 对象本身。</li>
</ul>
</li>
<li><p><strong>导入方式：</strong></p>
<ul>
<li>要导入具名导出，需要使用大括号 <code>&#123;&#125;</code> 和变量名：<code>import &#123; obj &#125; from &#39;./module&#39;</code>。</li>
<li>要导入默认导出，不需要使用大括号 <code>&#123;&#125;</code>，直接使用变量名即可：<code>import obj from &#39;./module&#39;</code>。</li>
</ul>
</li>
<li><p><strong>模块中导出的值：</strong></p>
<ul>
<li>具名导出：导出的值是一个变量，可以重命名。</li>
<li>默认导出：导出的值是变量本身，不能重命名。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<p><strong>具名导出：</strong></p>
<pre><code class="javascript">// module.js
export const obj = &#123; age: 1 &#125;

// main.js
import &#123; obj &#125; from &#39;./module&#39;

console.log(obj) // 输出: &#123; age: 1 &#125;
</code></pre>
<p><strong>默认导出：</strong></p>
<pre><code class="javascript">// module.js
const obj = &#123; age: 1 &#125;
export default obj

// main.js
import obj from &#39;./module&#39;

console.log(obj) // 输出: &#123; age: 1 &#125;
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>一个模块只能有一个默认导出。</li>
<li>如果一个模块既有具名导出又有默认导出，则默认导出必须放在最后。</li>
</ul>
<h2 id="hexo-not-foundd"><a href="#hexo-not-foundd" class="headerlink" title="hexo not foundd"></a>hexo not foundd</h2><p>$ npm remove -g hexo-cli<br>$ npm install -g hexo-cli</p>
<h2 id="hexo博客首页文章页数导航设置"><a href="#hexo博客首页文章页数导航设置" class="headerlink" title="hexo博客首页文章页数导航设置"></a>hexo博客首页文章页数导航设置</h2><ol>
<li>选择显示导航，设置在&#x2F;theme&#x2F;_config.yml中：<br>paginator: false<br>关闭页数导航</li>
<li>设置每页显示的文章数量：<br>index_generator:<br>  path: ‘’<br>  per_page: 0<br>  order_by: -date</li>
</ol>
<h2 id="git修改某个co"><a href="#git修改某个co" class="headerlink" title="git修改某个co"></a>git修改某个co</h2><p>mmit信息</p>
<pre><code>git commit --amend -m &quot;feat: add new feature&quot;
</code></pre>
<p>这将打开一个文本编辑器，其中包含当前提交消息。您可以编辑消息，然后保存并关闭编辑器以提交更改。</p>
<p>如果您想保留原始提交消息，可以使用 <code>-C</code> 选项：</p>
<pre><code>git commit --amend -C HEAD
</code></pre>
<p>这将打开一个文本编辑器，其中包含当前提交消息以及 <code>HEAD</code> 指向的提交消息。您可以编辑消息，然后保存并关闭编辑器以提交更改。</p>
<p>注意，如果是在已经提交同步到远程仓库之后，再修改commit信息，在push之前，需要先git pull,git merge才可以git push</p>
<h2 id="JavaScript判断一个对象为空对象"><a href="#JavaScript判断一个对象为空对象" class="headerlink" title="JavaScript判断一个对象为空对象"></a>JavaScript判断一个对象为空对象</h2><p>在 JavaScript 中，判断一个对象是否为空对象可以采用以下几种方法：</p>
<ol>
<li><strong>使用 Object.keys()</strong></li>
</ol>
<pre><code class="javascript">const obj = &#123;&#125;;

if (Object.keys(obj).length === 0) &#123;
  console.log(&quot;obj 是一个空对象&quot;);
&#125; else &#123;
  console.log(&quot;obj 不是一个空对象&quot;);
&#125;
</code></pre>
<ol start="3">
<li><strong>使用 JSON.stringify()</strong></li>
</ol>
<pre><code class="javascript">const obj = &#123;&#125;;

if (JSON.stringify(obj) === &quot;&#123;&#125;&quot;) &#123;
  console.log(&quot;obj 是一个空对象&quot;);
&#125; else &#123;
  console.log(&quot;obj 不是一个空对象&quot;);
&#125;
</code></pre>
<ol start="4">
<li><strong>使用lodash库</strong></li>
</ol>
<pre><code class="javascript">const obj = &#123;&#125;;

if (_.isEmpty(obj)) &#123;
  console.log(&quot;obj 是一个空对象&quot;);
&#125; else &#123;
  console.log(&quot;obj 不是一个空对象&quot;);
&#125;
</code></pre>
<p>需要注意的是，以上方法判断的都是 <strong>纯空对象</strong>，即没有任何属性和方法的对象。如果对象有原型属性或方法，则可能无法被这些方法判断为空对象。</p>
<h2 id="JavaScript双问号是什么意思"><a href="#JavaScript双问号是什么意思" class="headerlink" title="JavaScript双问号是什么意思"></a>JavaScript双问号是什么意思</h2><p><strong>JavaScript 中的双问号（??）运算符</strong>，也称为 <strong>空值合并运算符</strong>，用于检查其左侧的操作数是否为 <code>null</code> 或 <code>undefined</code>。如果左侧操作数为 <code>null</code> 或 <code>undefined</code>，则返回右侧操作数；否则，返回左侧操作数。</p>
<p><strong>语法：</strong></p>
<pre><code>expr1 ?? expr2
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="javascript">// 如果变量 x 为 null 或 undefined，则返回 &quot;默认值&quot;，否则返回 x
const result = x ?? &quot;默认值&quot;;
</code></pre>
<p><strong>双问号运算符的优点：</strong></p>
<ul>
<li>简洁：与传统的条件运算符（<code>? :</code>）相比，双问号运算符更加简洁。</li>
<li>可读性强：它使代码更容易阅读和理解。</li>
<li>可选链的替代方案：对于嵌套对象或数组，双问号运算符可以作为可选链（<code>?.</code>）的替代方案，以简化代码。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>双问号运算符仅在左侧操作数为 <code>null</code> 或 <code>undefined</code> 时才返回右侧操作数。对于其他假值（如 0、空字符串或 false），它将返回左侧操作数。</li>
<li>双问号运算符不能用于比较相等性。它只检查 <code>null</code> 和 <code>undefined</code> 值。</li>
</ul>
<h2 id="passport"><a href="#passport" class="headerlink" title="passport"></a>passport</h2><h3 id="登录POST"><a href="#登录POST" class="headerlink" title="登录POST"></a>登录POST</h3><ol>
<li>password.use返回的req.user：<br>export default passport.use(<br>  new Strategy({ usernameField: “username” }, (username, password, done) &#x3D;&gt; {<br> try {<br>   const findUser &#x3D; mockUsers.find((user) &#x3D;&gt; user.username &#x3D;&#x3D;&#x3D; username)<br>   if (!findUser || findUser.password !&#x3D;&#x3D; password)<br> throw new Error(“Unauthorized”)<br>   done(null, findUser.username)<br> } catch (err) {<br>   done(err, null)<br> }<br>  })<br>)</li>
</ol>
<p>第一次访问，不会触发deserialize。因为第一次运行，session中还不存在passport。这个阶段只会执行Strategy和serialize。通过strategy返回了req.user。<br>第二次访问，因为serialize已经done(null,user.id)，在session中添加了passport，userid字段，那么deserialize就会先执行，而后执行Strategy和serialize。通过descrialize返回req.user。</p>
<p>serialize序列化登录数据的时候，会在session中添加一个passport对象，passport包含一个user字段，这个字段就是存在数据库中的ObjectId.而deserialize的时候，就是根据这个ID找到这个用户信息的。</p>
<h3 id="GET-STATUS"><a href="#GET-STATUS" class="headerlink" title="GET STATUS"></a>GET STATUS</h3><p>只会触发deserialize。</p>
<ol>
<li><p>deserialize返回的也是req.user,跟passport.use的区别在于，passport.use是通过在post登录，通过中间件，passport.authenticate的形式返回的req.user。而deserialize则是在passport.session()中间件返回的。</p>
</li>
<li><p>serialize中，done(null, user.id)其实会在session中添加一个字段是{passport: id}</p>
</li>
</ol>
<h2 id="return-await-expression"><a href="#return-await-expression" class="headerlink" title="return await expression"></a>return await expression</h2><p>在您提供的两段代码中，主要区别在于在<code>return</code>语句中是否使用了额外的<code>await</code>关键字。</p>
<ol>
<li>第一段代码：</li>
</ol>
<pre><code class="javascript">export const hashPassword = async (password) =&gt; &#123;
  const salt = await bcrypt.genSalt(saltRound);
  return await bcrypt.hash(password, salt);
&#125;
</code></pre>
<ol start="2">
<li>第二段代码：</li>
</ol>
<pre><code class="javascript">export const hashPassword = async (password) =&gt; &#123;
  const salt = await bcrypt.genSalt(saltRound);
  return bcrypt.hash(password, salt);
&#125;
</code></pre>
<p>在第一段代码中，<code>return</code>语句中使用了两次<code>await</code>。首先在等待生成盐值的异步操作完成后，再次使用<code>await</code>来等待密码哈希的异步操作完成。这样确保了在返回哈希后的密码之前，函数会等待两个异步操作都完成。</p>
<p>而在第二段代码中，<code>return</code>语句中只使用了一次<code>await</code>，用于等待密码哈希的异步操作完成。这也是因为<code>async</code>函数会自动等待异步操作完成，所以在<code>return</code>语句中实际上只需要使用一次<code>await</code>就足够了。</p>
<p>总结来说，第一段代码中多余的<code>await</code>并没有错误，但在这种情况下是不必要的。第二段代码是更简洁和有效的写法，在<code>async</code>函数中可以直接返回带有<code>await</code>关键字的表达式，而不必在<code>return</code>语句中再次使用<code>await</code>。</p>
<h2 id="WRAP"><a href="#WRAP" class="headerlink" title="WRAP"></a>WRAP</h2><p>&#x2F;Applications&#x2F;Cloudflare WARP.app&#x2F;Contents&#x2F;Resources<br>&#x2F;Applications&#x2F;Cloudflare\ WARP.app&#x2F;Contents&#x2F;Resources<br>warp-cli set-custom-endpoint 188.114.96.198:2408</p>
<h2 id="为什么从字符串创建正则表达式需要两个反斜杠？"><a href="#为什么从字符串创建正则表达式需要两个反斜杠？" class="headerlink" title="为什么从字符串创建正则表达式需要两个反斜杠？"></a>为什么从字符串创建正则表达式需要两个反斜杠？</h2><ol>
<li>在JS字符串中，\反斜杠用于转义后面跟着的字符，比如，\n表示换行符，而假设一个符号没有任何转义的，比如\a，就表示a字母本身。这就产生了一个问题，在字符串中不需要转义的字符，但有可能在正则表达式中是需要转义的，比如说，.在字符串中是不需要转义的，console.log(‘.‘)就只会输出一个. ， 然而在正则表达式中，.表示的匹配一个任何字符。</li>
<li>因此，要在字符串中创建正则表达式就需要用到两个反斜杠，首先将反斜杠转义成反斜杠，再由反斜杠转义后面跟着的一个字符，这样就保证了反斜杠是肯定能转换后面跟着的一个字符，而不会像使用单个反斜杠的情况：只转义了在字符串中需要转义的。</li>
</ol>
<h2 id="Object-keys和Object-getOwnPropertyNames"><a href="#Object-keys和Object-getOwnPropertyNames" class="headerlink" title="Object.keys和Object.getOwnPropertyNames"></a>Object.keys和Object.getOwnPropertyNames</h2><p>使用 Object.keys 来获取对象自身的可枚举属性名。<br>使用 Object.getOwnPropertyNames 来获取对象自身的所有属性名（包括可枚举和不可枚举的属性）。</p>
<h2 id="先看原文还是看翻译"><a href="#先看原文还是看翻译" class="headerlink" title="先看原文还是看翻译"></a>先看原文还是看翻译</h2><p>阅读技术性文章时，先看翻译文章还是原文的效果更好，取决于你的语言能力和学习目标。以下是两种策略的优缺点：</p>
<h3 id="先看翻译文章"><a href="#先看翻译文章" class="headerlink" title="先看翻译文章"></a>先看翻译文章</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>理解更快</strong>：如果技术术语或内容对你来说比较陌生，翻译文章可以帮助你更快速地理解大意。</li>
<li><strong>节省时间</strong>：可以减少因语言障碍而产生的阅读障碍，更专注于理解技术内容。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>翻译质量的依赖</strong>：翻译文章可能会因为翻译者的理解或表达能力而产生偏差，有时原文的意思会被误解或弱化。</li>
<li><strong>技术细节可能丢失</strong>：某些技术术语或细节在翻译过程中可能被简化或忽略。</li>
</ul>
<h3 id="先看原文"><a href="#先看原文" class="headerlink" title="先看原文"></a>先看原文</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>原汁原味的表达</strong>：可以直接接触作者的原始思想，确保技术细节和表达的准确性。</li>
<li><strong>提高语言能力</strong>：有助于提高你的技术英语水平，增强对原版技术文档的阅读能力。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>理解速度可能较慢</strong>：如果你对原文中的技术术语或表达不熟悉，阅读速度可能会降低，需要花费更多时间理解。</li>
<li><strong>容易因语言问题分心</strong>：如果对内容理解不透彻，可能会因语言障碍而分心，影响对技术内容的掌握。</li>
</ul>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ol>
<li><p><strong>如果你熟悉技术主题并且语言能力较强</strong>：建议先读原文，这样可以获得最准确的信息，并提高你的技术语言能力。</p>
</li>
<li><p><strong>如果你对技术主题不太熟悉或语言能力较弱</strong>：可以先读翻译文章获取整体理解，然后再读原文来核实细节和加深理解。</p>
</li>
<li><p><strong>结合两者</strong>：在读完翻译文章后，再阅读原文，特别是在遇到疑问或需要深入了解时，这样可以帮助你在理解的同时提高语言能力。</p>
</li>
</ol>
<p>通过这种策略，你可以在确保理解的前提下，逐步提升阅读原文的能力。</p>
<h1 id="npm源设置"><a href="#npm源设置" class="headerlink" title="npm源设置"></a>npm源设置</h1><p>官方：<br>npm config set registry <a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a><br>镜像：<br>npm config set registry <a target="_blank" rel="noopener" href="https://registry.npmmirror.com/">https://registry.npmmirror.com/</a></p>
<p class="backHome"><span></span><a href="/">Back</a><span>↶</span></p></div><script src="/js/highlight.min.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>